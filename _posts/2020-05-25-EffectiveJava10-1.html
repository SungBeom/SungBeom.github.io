---
layout: post
title: "[Effective Java]공유 중인 가변 데이터는 동기화해 사용하라"
subtitle: "동시성, 첫 번째 아이템"
date: 2020-05-25 23:29:00
background: '/img/posts/EffectiveJava.jpg'
---

<h2 class="section-heading">동기화의 목적 및 필요성</h2>

<p style="font-family: NanumGothic">
    synchronized 키워드는 해당 메소드나 블록을 한번에 한 스레드씩 수행하도록 보장한다.
    많은 프로그래머가 동기화를 베타적 실행, 즉 한 스레드가 변경하는 중이라서 상태가 일관되지 않은 순간의 객체를 다른 스레드가 보지 못하게 막는 용도로만 생각한다.
    이 관점에서 동기화를 제대로 사용하면 어떤 메소드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없을 것이다.
</p>

<p style="font-family: NanumGothic">
    맞는 설명이지만, 동기화에는 중요한 기능이 하나 더 있다.
    동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다.
    동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론, 동기화된 메소드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.
</p>

<p style="font-family: NanumGothic">
    언어 명세상 long과 double 외의 변수를 읽고 쓰는 동작은 원자적(atomic)이다.
    여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장한다는 뜻이다.
    때문에 성능을 높이려면 원자적 데이터를 읽고 쓸 때는 동기화하지 말아야겠다고 생각하기 쉬운데, 아주 위험한 발상이다.
    자바 언어 명세는 스레드가 필드를 읽을 때 항상 '수정이 완전히 반영된' 값을 얻는다고 보장하지만, 한 스레드가 저장한 값이 다른 스레드에게 '보이는가'는 보장하지 않는다.
    <strong>동기화는 베타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.</strong>
<br>

<p style="font-family: NanumGothic">
    공유 중인 가변 데이터를 비록 원자적으로 읽고 쓸 수 있을지라도 동기화에 실패하면 처참한 결과로 이어질 수 있다.
    다른 스레드를 멈추는 작업을 생각해보자.
    Thread.stop 메소드는 안전하지 않아 이미 오래전에 사용 자제(deprecated) API로 지정되었으니, <strong>Thread.stop은 사용하지 말자!</strong>
    다른 스레드를 멈추는 올바른 방법은 다음과 같다.
</p>

<h2 class="section-heading" style="color: red">핵심 정리</h2>

<p style="font-family: NanumGothic">
    여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.
    동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할 수도 있다.
    공유되는 가변 데이터를 동기화하는 데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다.
    이는 디버깅 난이도가 가장 높은 문제에 속한다.
    간헐적이거나 특정 타이밍에만 발생할 수도 있고, VM에 따라 현상이 달라지기도 한다.
    베타적 실행은 필요 없고 스레드끼리의 통신만 필요하다면 volatile 한정자만으로 동기화할 수 있다.
    다만 올바로 사용하기가 까다롭다.
</p>
